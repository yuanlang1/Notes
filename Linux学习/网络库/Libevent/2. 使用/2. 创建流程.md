# 使用

---

## 1. 初始化`libevent`事件基础结构

初始化`libevent`的事件基础结构，事件处理的核心

```c
struct event_base * base = event_base_new(void);
```

---

## 2. 创建事件处理函数

例如：
一个处理套接字可读事件的函数

```c
void handle_socket_read(evutil_socket_t fd, short events, void* arg) {
    // 处理套接字读事件的代码
}

```

---

## 3. 创建事件

创建一个事件，将它与事件处理函数关联，并将它添加到事件基础结构中

创建一个事件，将它与事件处理函数关联：

添加到注册事件队列中，并将对应的事件注册到事件多路分发器上

```c
struct event* ev = event_new(struct event_base* base, evutil_socket_t fd, short events, event_callback_fn callback, void* arg);

base：指向事件基础架构的指针

fd：要监听的套字节文件描述符

events：指定事件类型，如可读，可写等

callback：事件发生时要调用的回调函数

arg：传递给回调函数的自定义参数
```

将事件添加到事件基础结构中，以便监听：

```c
int event_add(struct event* ev, const struct timeval* tv);

ev：指向事件对象的指针

tv：指定事件的超时时间，可以是NULL
```

---

## 4. 加入事件循环

进入事件循环并等待事件的发生，并调用相应的事件处理函数

```c
int event_base_dispatch(struct event_base* base);

base：指向事件基础架构的指针

返回0表示成功，-1表示出错
```

---

## 5. 释放资源

```c
释放事件对象
void event_free(struct event* ev);

释放事件基础结构资源

void event_base_free(struct event_base* base)
```